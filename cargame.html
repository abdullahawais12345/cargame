<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Car Racing Game - 10 Levels</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    .game-container {
      position: relative;
      width: 100%;
      max-width: 500px;
      padding: 20px;
    }

    /* Menu Screen */
    .menu-screen {
      background: linear-gradient(145deg, #2d2d44, #1a1a2e);
      border-radius: 20px;
      padding: 40px 30px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .menu-screen h1 {
      font-size: 2.5rem;
      background: linear-gradient(135deg, #ff6b6b, #feca57);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      text-shadow: 0 0 30px rgba(255, 107, 107, 0.3);
    }

    .menu-screen p {
      color: #888;
      margin-bottom: 30px;
    }

    .levels-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      margin-bottom: 30px;
    }

    .level-btn {
      aspect-ratio: 1;
      border: none;
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .level-btn.unlocked {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }

    .level-btn.unlocked:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
    }

    .level-btn.locked {
      background: #2a2a3e;
      color: #555;
      cursor: not-allowed;
    }

    .level-btn.completed {
      background: linear-gradient(135deg, #11998e, #38ef7d);
      color: white;
      box-shadow: 0 4px 15px rgba(56, 239, 125, 0.4);
    }

    .level-btn.completed::after {
      content: '‚úì';
      position: absolute;
      top: 2px;
      right: 5px;
      font-size: 0.7rem;
    }

    .high-score-display {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 15px;
      margin-top: 20px;
    }

    .high-score-display h3 {
      color: #feca57;
      margin-bottom: 10px;
    }

    .high-score-display p {
      color: #aaa;
      margin: 5px 0;
      font-size: 0.9rem;
    }

    /* Game Screen */
    .game-screen {
      display: none;
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 0 10px;
    }

    .game-info {
      display: flex;
      gap: 20px;
    }

    .info-box {
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 16px;
      border-radius: 20px;
      color: white;
      font-size: 0.9rem;
    }

    .info-box span {
      color: #feca57;
      font-weight: bold;
    }

    .back-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .game-canvas-container {
      position: relative;
      background: #1a1a2e;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: auto;
    }

    .power-up-indicators {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 10px;
    }

    .power-indicator {
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.75rem;
      font-weight: bold;
      display: none;
    }

    .power-indicator.shield {
      background: rgba(100, 149, 237, 0.8);
      color: white;
    }

    .power-indicator.speed {
      background: rgba(255, 165, 0, 0.8);
      color: white;
    }

    .power-indicator.active {
      display: block;
      animation: pulse 0.5s infinite alternate;
    }

    @keyframes pulse {
      from { transform: scale(1); }
      to { transform: scale(1.1); }
    }

    .progress-bar {
      margin-top: 15px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      height: 20px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea, #764ba2);
      transition: width 0.3s ease;
      border-radius: 10px;
    }

    .progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .mobile-controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    .control-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(145deg, #3a3a5c, #2a2a44);
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:active {
      transform: scale(0.95);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .control-btn.pause-btn {
      width: 60px;
      height: 60px;
      background: linear-gradient(145deg, #feca57, #d69e2e);
      color: #1a1a2e;
    }

    .control-btn.pause-btn:hover {
      transform: scale(1.05);
    }

    /* Pause Overlay */
    .pause-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 50;
      border-radius: 20px;
    }

    .pause-overlay.active {
      display: flex;
    }

    .pause-overlay h2 {
      color: #feca57;
      font-size: 2rem;
      margin-bottom: 20px;
    }

    .pause-overlay .pause-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .pause-overlay .pause-btn-action {
      padding: 15px 40px;
      border: none;
      border-radius: 25px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .pause-overlay .pause-btn-action.resume {
      background: linear-gradient(135deg, #38ef7d, #11998e);
      color: white;
    }

    .pause-overlay .pause-btn-action.menu {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .pause-overlay .pause-btn-action:hover {
      transform: translateY(-2px);
    }

    /* Overlay Screens */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .overlay.active {
      display: flex;
    }

    .overlay-content {
      background: linear-gradient(145deg, #2d2d44, #1a1a2e);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 350px;
      width: 90%;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .overlay-content h2 {
      font-size: 2rem;
      margin-bottom: 15px;
    }

    .overlay-content.win h2 {
      color: #38ef7d;
    }

    .overlay-content.lose h2 {
      color: #ff6b6b;
    }

    .overlay-content p {
      color: #aaa;
      margin-bottom: 25px;
    }

    .overlay-content .score-display {
      font-size: 3rem;
      font-weight: bold;
      color: #feca57;
      margin: 20px 0;
    }

    .overlay-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .overlay-btn {
      padding: 12px 30px;
      border: none;
      border-radius: 25px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .overlay-btn.primary {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
    }

    .overlay-btn.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .overlay-btn:hover {
      transform: translateY(-2px);
    }

    .stars {
      font-size: 2.5rem;
      margin: 15px 0;
    }

    /* Responsive */
    @media (max-width: 500px) {
      .game-container {
        padding: 10px;
      }

      .menu-screen h1 {
        font-size: 1.8rem;
      }

      .levels-grid {
        gap: 8px;
      }

      .level-btn {
        font-size: 1rem;
      }

      .game-info {
        gap: 10px;
      }

      .info-box {
        padding: 6px 12px;
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <!-- Menu Screen -->
    <div class="menu-screen" id="menuScreen">
      <h1>üèéÔ∏è Car Racing</h1>
      <p>Select a level to play</p>
      <div class="levels-grid" id="levelsGrid"></div>
      <div class="high-score-display">
        <h3>üèÜ High Scores</h3>
        <div id="highScoresList"></div>
      </div>
    </div>

    <!-- Game Screen -->
    <div class="game-screen" id="gameScreen">
      <div class="game-header">
        <button class="back-btn" onclick="goToMenu()">‚Üê Menu</button>
        <div class="game-info">
          <div class="info-box">Level: <span id="currentLevel">1</span></div>
          <div class="info-box">Score: <span id="scoreDisplay">0</span></div>
          <div class="info-box">‚ù§Ô∏è <span id="livesDisplay">3</span></div>
        </div>
      </div>

      <div class="game-canvas-container">
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <div class="power-up-indicators">
          <div class="power-indicator shield" id="shieldIndicator">üõ°Ô∏è Shield</div>
          <div class="power-indicator speed" id="speedIndicator">‚ö° Speed</div>
        </div>
        <!-- Pause Overlay -->
        <div class="pause-overlay" id="pauseOverlay">
          <h2>‚è∏Ô∏è Paused</h2>
          <div class="pause-buttons">
            <button class="pause-btn-action resume" onclick="resumeGame()">‚ñ∂Ô∏è Resume</button>
            <button class="pause-btn-action menu" onclick="goToMenu()">üè† Menu</button>
          </div>
        </div>
      </div>

      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
        <div class="progress-text" id="progressText">0 / 100</div>
      </div>

      <div class="mobile-controls">
        <button class="control-btn" id="leftBtn">‚óÄ</button>
        <button class="control-btn pause-btn" id="pauseBtn">‚è∏Ô∏è</button>
        <button class="control-btn" id="rightBtn">‚ñ∂</button>
      </div>
    </div>
  </div>

  <!-- Win Overlay -->
  <div class="overlay" id="winOverlay">
    <div class="overlay-content win">
      <h2>üéâ Level Complete!</h2>
      <div class="stars" id="starsDisplay">‚≠ê‚≠ê‚≠ê</div>
      <div class="score-display" id="finalScore">0</div>
      <p>Amazing driving!</p>
      <div class="overlay-buttons">
        <button class="overlay-btn primary" onclick="nextLevel()">Next Level ‚Üí</button>
        <button class="overlay-btn secondary" onclick="goToMenu()">Menu</button>
      </div>
    </div>
  </div>

  <!-- Lose Overlay -->
  <div class="overlay" id="loseOverlay">
    <div class="overlay-content lose">
      <h2>üí• Game Over</h2>
      <div class="score-display" id="loseScore">0</div>
      <p>Better luck next time!</p>
      <div class="overlay-buttons">
        <button class="overlay-btn primary" onclick="restartLevel()">Try Again</button>
        <button class="overlay-btn secondary" onclick="goToMenu()">Menu</button>
      </div>
    </div>
  </div>

  <script>
    // Game State
    const LEVELS = [
      { id: 1, name: "Beginner", targetScore: 50, enemySpeed: 2, spawnInterval: 2000, maxEnemies: 2 },
      { id: 2, name: "Easy", targetScore: 80, enemySpeed: 2.5, spawnInterval: 1800, maxEnemies: 2 },
      { id: 3, name: "Normal", targetScore: 100, enemySpeed: 3, spawnInterval: 1600, maxEnemies: 3 },
      { id: 4, name: "Medium", targetScore: 130, enemySpeed: 3.5, spawnInterval: 1400, maxEnemies: 3 },
      { id: 5, name: "Challenging", targetScore: 160, enemySpeed: 4, spawnInterval: 1200, maxEnemies: 4 },
      { id: 6, name: "Hard", targetScore: 200, enemySpeed: 4.5, spawnInterval: 1100, maxEnemies: 4 },
      { id: 7, name: "Very Hard", targetScore: 250, enemySpeed: 5, spawnInterval: 1000, maxEnemies: 5 },
      { id: 8, name: "Expert", targetScore: 300, enemySpeed: 5.5, spawnInterval: 900, maxEnemies: 5 },
      { id: 9, name: "Master", targetScore: 350, enemySpeed: 6, spawnInterval: 800, maxEnemies: 6 },
      { id: 10, name: "Legend", targetScore: 400, enemySpeed: 7, spawnInterval: 700, maxEnemies: 7 }
    ];

    let gameState = {
      currentLevel: 1,
      score: 0,
      lives: 3,
      isPlaying: false,
      isPaused: false,
      unlockedLevels: [1],
      highScores: {},
      completedLevels: []
    };

    // Canvas and Context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game Objects
    let player = { x: 175, y: 500, width: 50, height: 80 };
    let enemies = [];
    let coins = [];
    let powerUps = [];
    let roadOffset = 0;

    // Power-up states
    let hasShield = false;
    let hasSpeedBoost = false;
    let shieldTimer = null;
    let speedTimer = null;

    // Animation
    let animationId = null;
    let lastSpawnTime = 0;
    let lastCoinSpawnTime = 0;
    let lastPowerUpSpawnTime = 0;

    // Controls
    let keys = { left: false, right: false };

    // Load saved data
    function loadGameData() {
      const saved = localStorage.getItem('carRacingGame');
      if (saved) {
        const data = JSON.parse(saved);
        gameState.unlockedLevels = data.unlockedLevels || [1];
        gameState.highScores = data.highScores || {};
        gameState.completedLevels = data.completedLevels || [];
      }
    }

    // Save game data
    function saveGameData() {
      localStorage.setItem('carRacingGame', JSON.stringify({
        unlockedLevels: gameState.unlockedLevels,
        highScores: gameState.highScores,
        completedLevels: gameState.completedLevels
      }));
    }

    // Render menu
    function renderMenu() {
      const grid = document.getElementById('levelsGrid');
      grid.innerHTML = '';

      LEVELS.forEach(level => {
        const btn = document.createElement('button');
        btn.className = 'level-btn';
        btn.textContent = level.id;

        if (gameState.completedLevels.includes(level.id)) {
          btn.classList.add('completed');
        } else if (gameState.unlockedLevels.includes(level.id)) {
          btn.classList.add('unlocked');
        } else {
          btn.classList.add('locked');
        }

        if (gameState.unlockedLevels.includes(level.id)) {
          btn.onclick = () => startLevel(level.id);
        }

        grid.appendChild(btn);
      });

      // High scores
      const scoresList = document.getElementById('highScoresList');
      scoresList.innerHTML = '';
      Object.entries(gameState.highScores).forEach(([level, score]) => {
        const p = document.createElement('p');
        p.textContent = `Level ${level}: ${score} points`;
        scoresList.appendChild(p);
      });

      if (Object.keys(gameState.highScores).length === 0) {
        scoresList.innerHTML = '<p>No scores yet!</p>';
      }
    }

    // Start level
    function startLevel(levelId) {
      gameState.currentLevel = levelId;
      gameState.score = 0;
      gameState.lives = 3;
      gameState.isPlaying = true;

      // Reset game objects
      player = { x: 175, y: 500, width: 50, height: 80 };
      enemies = [];
      coins = [];
      powerUps = [];
      hasShield = false;
      hasSpeedBoost = false;

      // Clear timers
      if (shieldTimer) clearTimeout(shieldTimer);
      if (speedTimer) clearTimeout(speedTimer);

      // Update UI
      document.getElementById('menuScreen').style.display = 'none';
      document.getElementById('gameScreen').style.display = 'block';
      document.getElementById('currentLevel').textContent = levelId;
      updateUI();
      updatePowerIndicators();

      // Start game loop
      lastSpawnTime = Date.now();
      lastCoinSpawnTime = Date.now();
      lastPowerUpSpawnTime = Date.now();
      gameLoop();
    }

    // Go to menu
    function goToMenu() {
      gameState.isPlaying = false;
      gameState.isPaused = false;
      if (animationId) cancelAnimationFrame(animationId);
      
      document.getElementById('gameScreen').style.display = 'none';
      document.getElementById('menuScreen').style.display = 'block';
      document.getElementById('winOverlay').classList.remove('active');
      document.getElementById('loseOverlay').classList.remove('active');
      document.getElementById('pauseOverlay').classList.remove('active');
      
      renderMenu();
    }

    // Pause game
    function pauseGame() {
      if (!gameState.isPlaying || gameState.isPaused) return;
      gameState.isPaused = true;
      if (animationId) cancelAnimationFrame(animationId);
      document.getElementById('pauseOverlay').classList.add('active');
    }

    // Resume game
    function resumeGame() {
      if (!gameState.isPaused) return;
      gameState.isPaused = false;
      document.getElementById('pauseOverlay').classList.remove('active');
      lastSpawnTime = Date.now();
      lastCoinSpawnTime = Date.now();
      lastPowerUpSpawnTime = Date.now();
      gameLoop();
    }

    // Toggle pause
    function togglePause() {
      if (gameState.isPaused) {
        resumeGame();
      } else {
        pauseGame();
      }
    }

    // Update UI
    function updateUI() {
      document.getElementById('scoreDisplay').textContent = gameState.score;
      document.getElementById('livesDisplay').textContent = gameState.lives;
      
      const level = LEVELS[gameState.currentLevel - 1];
      const progress = Math.min((gameState.score / level.targetScore) * 100, 100);
      document.getElementById('progressFill').style.width = progress + '%';
      document.getElementById('progressText').textContent = `${gameState.score} / ${level.targetScore}`;
    }

    // Update power indicators
    function updatePowerIndicators() {
      document.getElementById('shieldIndicator').classList.toggle('active', hasShield);
      document.getElementById('speedIndicator').classList.toggle('active', hasSpeedBoost);
    }

    // Spawn enemy
    function spawnEnemy() {
      const level = LEVELS[gameState.currentLevel - 1];
      if (enemies.length < level.maxEnemies) {
        const lane = Math.floor(Math.random() * 3);
        const x = 50 + lane * 120;
        enemies.push({
          x: x,
          y: -80,
          width: 50,
          height: 80,
          speed: level.enemySpeed + Math.random()
        });
      }
    }

    // Spawn coin
    function spawnCoin() {
      const lane = Math.floor(Math.random() * 4);
      const x = 30 + lane * 90;
      coins.push({
        x: x,
        y: -30,
        radius: 15,
        value: 10
      });
    }

    // Spawn power-up
    function spawnPowerUp() {
      if (Math.random() < 0.3) {
        const lane = Math.floor(Math.random() * 3);
        const x = 60 + lane * 120;
        const type = Math.random() < 0.5 ? 'shield' : 'speed';
        powerUps.push({
          x: x,
          y: -30,
          size: 30,
          type: type
        });
      }
    }

    // Check collision
    function checkCollision(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }

    // Check circle collision
    function checkCircleCollision(circle, rect) {
      const distX = Math.abs(circle.x - rect.x - rect.width / 2);
      const distY = Math.abs(circle.y - rect.y - rect.height / 2);
      
      if (distX > (rect.width / 2 + circle.radius)) return false;
      if (distY > (rect.height / 2 + circle.radius)) return false;
      
      if (distX <= (rect.width / 2)) return true;
      if (distY <= (rect.height / 2)) return true;
      
      const dx = distX - rect.width / 2;
      const dy = distY - rect.height / 2;
      return (dx * dx + dy * dy <= (circle.radius * circle.radius));
    }

    // Draw road
    function drawRoad() {
      // Road background
      ctx.fillStyle = '#2a2a3e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Road surface
      ctx.fillStyle = '#3a3a5a';
      ctx.fillRect(20, 0, 360, canvas.height);

      // Road lines
      ctx.strokeStyle = '#feca57';
      ctx.lineWidth = 3;
      ctx.setLineDash([40, 30]);
      ctx.lineDashOffset = -roadOffset;

      for (let i = 1; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(20 + i * 90, 0);
        ctx.lineTo(20 + i * 90, canvas.height);
        ctx.stroke();
      }

      ctx.setLineDash([]);

      // Side barriers
      ctx.fillStyle = '#ff6b6b';
      for (let y = -40 + (roadOffset % 80); y < canvas.height; y += 80) {
        ctx.fillRect(5, y, 12, 40);
        ctx.fillRect(383, y, 12, 40);
      }

      roadOffset += hasSpeedBoost ? 15 : 8;
    }

    // Draw player
    function drawPlayer() {
      // Shield effect
      if (hasShield) {
        ctx.beginPath();
        ctx.arc(player.x + player.width / 2, player.y + player.height / 2, 50, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(100, 149, 237, 0.6)';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.fillStyle = 'rgba(100, 149, 237, 0.2)';
        ctx.fill();
      }

      // Car body
      ctx.fillStyle = '#667eea';
      ctx.beginPath();
      ctx.roundRect(player.x, player.y + 15, player.width, player.height - 15, 8);
      ctx.fill();

      // Car top
      ctx.fillStyle = '#5a67d8';
      ctx.beginPath();
      ctx.roundRect(player.x + 5, player.y, player.width - 10, 40, 5);
      ctx.fill();

      // Windshield
      ctx.fillStyle = '#a0aec0';
      ctx.beginPath();
      ctx.roundRect(player.x + 8, player.y + 5, player.width - 16, 20, 3);
      ctx.fill();

      // Wheels
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(player.x - 5, player.y + 10, 8, 20);
      ctx.fillRect(player.x + player.width - 3, player.y + 10, 8, 20);
      ctx.fillRect(player.x - 5, player.y + 55, 8, 20);
      ctx.fillRect(player.x + player.width - 3, player.y + 55, 8, 20);

      // Headlights
      ctx.fillStyle = '#feca57';
      ctx.beginPath();
      ctx.arc(player.x + 10, player.y + player.height - 5, 5, 0, Math.PI * 2);
      ctx.arc(player.x + player.width - 10, player.y + player.height - 5, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw enemy
    function drawEnemy(enemy) {
      // Car body
      ctx.fillStyle = '#e53e3e';
      ctx.beginPath();
      ctx.roundRect(enemy.x, enemy.y + 15, enemy.width, enemy.height - 15, 8);
      ctx.fill();

      // Car top
      ctx.fillStyle = '#c53030';
      ctx.beginPath();
      ctx.roundRect(enemy.x + 5, enemy.y + 40, enemy.width - 10, 35, 5);
      ctx.fill();

      // Windshield
      ctx.fillStyle = '#2d3748';
      ctx.beginPath();
      ctx.roundRect(enemy.x + 8, enemy.y + 45, enemy.width - 16, 20, 3);
      ctx.fill();

      // Wheels
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(enemy.x - 5, enemy.y + 10, 8, 20);
      ctx.fillRect(enemy.x + enemy.width - 3, enemy.y + 10, 8, 20);
      ctx.fillRect(enemy.x - 5, enemy.y + 55, 8, 20);
      ctx.fillRect(enemy.x + enemy.width - 3, enemy.y + 55, 8, 20);

      // Taillights
      ctx.fillStyle = '#fc8181';
      ctx.beginPath();
      ctx.arc(enemy.x + 10, enemy.y + 5, 5, 0, Math.PI * 2);
      ctx.arc(enemy.x + enemy.width - 10, enemy.y + 5, 5, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw coin
    function drawCoin(coin) {
      ctx.beginPath();
      ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#feca57';
      ctx.fill();
      ctx.strokeStyle = '#d69e2e';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#d69e2e';
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('$', coin.x, coin.y);
    }

    // Draw power-up
    function drawPowerUp(powerUp) {
      ctx.beginPath();
      ctx.arc(powerUp.x, powerUp.y, powerUp.size / 2, 0, Math.PI * 2);
      
      if (powerUp.type === 'shield') {
        ctx.fillStyle = 'rgba(100, 149, 237, 0.8)';
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üõ°Ô∏è', powerUp.x, powerUp.y);
      } else {
        ctx.fillStyle = 'rgba(255, 165, 0, 0.8)';
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('‚ö°', powerUp.x, powerUp.y);
      }
    }

    // Game loop
    function gameLoop() {
      if (!gameState.isPlaying || gameState.isPaused) return;

      const level = LEVELS[gameState.currentLevel - 1];
      const now = Date.now();

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw road
      drawRoad();

      // Spawn enemies
      if (now - lastSpawnTime > level.spawnInterval) {
        spawnEnemy();
        lastSpawnTime = now;
      }

      // Spawn coins
      if (now - lastCoinSpawnTime > 800) {
        spawnCoin();
        lastCoinSpawnTime = now;
      }

      // Spawn power-ups
      if (now - lastPowerUpSpawnTime > 5000) {
        spawnPowerUp();
        lastPowerUpSpawnTime = now;
      }

      // Move player
      const moveSpeed = hasSpeedBoost ? 8 : 5;
      if (keys.left && player.x > 25) player.x -= moveSpeed;
      if (keys.right && player.x < 325) player.x += moveSpeed;

      // Update and draw enemies
      enemies = enemies.filter(enemy => {
        enemy.y += enemy.speed;

        // Check collision with player
        if (checkCollision(player, enemy)) {
          if (hasShield) {
            hasShield = false;
            updatePowerIndicators();
            return false; // Remove enemy
          } else {
            gameState.lives--;
            updateUI();
            if (gameState.lives <= 0) {
              gameOver();
              return false;
            }
            return false; // Remove enemy
          }
        }

        // Remove if off screen
        if (enemy.y > canvas.height) {
          gameState.score += 5;
          updateUI();
          checkLevelComplete();
          return false;
        }

        drawEnemy(enemy);
        return true;
      });

      // Update and draw coins
      coins = coins.filter(coin => {
        coin.y += 4;

        if (checkCircleCollision(coin, player)) {
          gameState.score += coin.value;
          updateUI();
          checkLevelComplete();
          return false;
        }

        if (coin.y > canvas.height + 20) return false;

        drawCoin(coin);
        return true;
      });

      // Update and draw power-ups
      powerUps = powerUps.filter(powerUp => {
        powerUp.y += 3;

        if (checkCircleCollision({ x: powerUp.x, y: powerUp.y, radius: powerUp.size / 2 }, player)) {
          activatePowerUp(powerUp.type);
          return false;
        }

        if (powerUp.y > canvas.height + 20) return false;

        drawPowerUp(powerUp);
        return true;
      });

      // Draw player
      drawPlayer();

      animationId = requestAnimationFrame(gameLoop);
    }

    // Activate power-up
    function activatePowerUp(type) {
      if (type === 'shield') {
        hasShield = true;
        if (shieldTimer) clearTimeout(shieldTimer);
        shieldTimer = setTimeout(() => {
          hasShield = false;
          updatePowerIndicators();
        }, 8000);
      } else if (type === 'speed') {
        hasSpeedBoost = true;
        if (speedTimer) clearTimeout(speedTimer);
        speedTimer = setTimeout(() => {
          hasSpeedBoost = false;
          updatePowerIndicators();
        }, 5000);
      }
      updatePowerIndicators();
    }

    // Check level complete
    function checkLevelComplete() {
      const level = LEVELS[gameState.currentLevel - 1];
      if (gameState.score >= level.targetScore) {
        levelComplete();
      }
    }

    // Level complete
    function levelComplete() {
      gameState.isPlaying = false;
      if (animationId) cancelAnimationFrame(animationId);

      // Update high score
      if (!gameState.highScores[gameState.currentLevel] || 
          gameState.score > gameState.highScores[gameState.currentLevel]) {
        gameState.highScores[gameState.currentLevel] = gameState.score;
      }

      // Mark level as completed
      if (!gameState.completedLevels.includes(gameState.currentLevel)) {
        gameState.completedLevels.push(gameState.currentLevel);
      }

      // Unlock next level
      const nextLevel = gameState.currentLevel + 1;
      if (nextLevel <= 10 && !gameState.unlockedLevels.includes(nextLevel)) {
        gameState.unlockedLevels.push(nextLevel);
      }

      saveGameData();

      // Calculate stars
      const level = LEVELS[gameState.currentLevel - 1];
      const ratio = gameState.score / level.targetScore;
      let stars = '‚≠ê';
      if (ratio >= 1.5) stars = '‚≠ê‚≠ê‚≠ê';
      else if (ratio >= 1.2) stars = '‚≠ê‚≠ê';

      document.getElementById('starsDisplay').textContent = stars;
      document.getElementById('finalScore').textContent = gameState.score;
      document.getElementById('winOverlay').classList.add('active');
    }

    // Game over
    function gameOver() {
      gameState.isPlaying = false;
      if (animationId) cancelAnimationFrame(animationId);

      document.getElementById('loseScore').textContent = gameState.score;
      document.getElementById('loseOverlay').classList.add('active');
    }

    // Next level
    function nextLevel() {
      document.getElementById('winOverlay').classList.remove('active');
      const next = gameState.currentLevel + 1;
      if (next <= 10) {
        startLevel(next);
      } else {
        goToMenu();
      }
    }

    // Restart level
    function restartLevel() {
      document.getElementById('loseOverlay').classList.remove('active');
      startLevel(gameState.currentLevel);
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
      if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
        if (gameState.isPlaying) togglePause();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    });

    // Pause button
    document.getElementById('pauseBtn').addEventListener('click', togglePause);

    // Mobile controls
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');

    leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; });
    leftBtn.addEventListener('touchend', () => { keys.left = false; });
    leftBtn.addEventListener('mousedown', () => { keys.left = true; });
    leftBtn.addEventListener('mouseup', () => { keys.left = false; });
    leftBtn.addEventListener('mouseleave', () => { keys.left = false; });

    rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.right = true; });
    rightBtn.addEventListener('touchend', () => { keys.right = false; });
    rightBtn.addEventListener('mousedown', () => { keys.right = true; });
    rightBtn.addEventListener('mouseup', () => { keys.right = false; });
    rightBtn.addEventListener('mouseleave', () => { keys.right = false; });

    // Initialize
    loadGameData();
    renderMenu();
  </script>
</body>
</html>
